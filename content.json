{"meta":{"title":"ccbu's blog","subtitle":null,"description":null,"author":"ccbu","url":"http://blog.ccbu.cc"},"pages":[{"title":"about","date":"2017-12-03T09:58:34.000Z","updated":"2017-12-08T07:57:17.568Z","comments":true,"path":"about/index.html","permalink":"http://blog.ccbu.cc/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Android Drawable介绍","slug":"Android Drawable介绍","date":"2017-12-06T14:01:00.000Z","updated":"2017-12-08T07:57:17.568Z","comments":true,"path":"2017/12/06/Android Drawable介绍/","link":"","permalink":"http://blog.ccbu.cc/2017/12/06/Android Drawable介绍/","excerpt":"","text":"Android系统中将可绘制对象被抽象为Drawable,不同的绘制资源对应着不同的Drawable类型。Android FrameWork提供了常用的Drawable，Android控件的绘制资源基本都是通过Drawable形式实现的。一般情况下，开发者是不会直接接触Drawable的具体实现的，Drawable资源一般都放在res/drawable目录下，用户通过图片，xml格式的Drawable资源来使用。 Android内置的比较常用的Drawable类型包括：ColorDrawable、GradientDrawable、ShapeDrawable、BitmapDrawable、 NinePatchDrawable、InsetDrawable、ClipDrawable、ScaleDrawable、RotateDrawable、AnimationDrawable、LayerDrawable、LevelListDrawable、StateListDrawable、TransitionDrawable。 一般情况下，除了图片资源是直接放在res/drawable下（android studio中图片放在res/minmap下），其他的Drawable都是以xml格式实现的，开发者通过在xml中使用shape,selector,level-list等标签来实现对应的Drawable，从而实现相应的可绘制资源的定义，最终view通过绘制这些Drawable来实现我们想要的显示效果。 Drawable中xml标签与Drawable对象的对应关系如以下表格所示: xml标签 Drawable对象 StateListDrawable LevelListDrawable LayerDrawable TransitionDrawable ColorDrawable GradientDrawable ScaleDrawable VectorDrawable ClipDrawable RotateDrawable AnimationDrawable InsetDrawable BitmapDrawable NinePatchDrawable 下面我们通过Framework的源代码来探索一下Drawable的加载过程，一般情况下，我们通过getResources().getDrawable(int id);的方式去加载。顺着这条线往下看，getDrawable-&gt;loadDrawable-&gt;loadDrawableForCookie-&gt;Drawable.createFromXml-&gt;createFromXmlInner,来看android\\graphics\\drawable\\Drawable.java的createFromXmlInner函数的实现代码。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static Drawable createFromXmlInner(Resources r, XmlPullParser parser, AttributeSet attrs, Theme theme) throws XmlPullParserException, IOException &#123; final Drawable drawable; final String name = parser.getName(); if (name.equals(&quot;selector&quot;)) &#123; drawable = new StateListDrawable(); &#125; else if (name.equals(&quot;animated-selector&quot;)) &#123; drawable = new AnimatedStateListDrawable(); &#125; else if (name.equals(&quot;level-list&quot;)) &#123; drawable = new LevelListDrawable(); &#125; else if (name.equals(&quot;layer-list&quot;)) &#123; drawable = new LayerDrawable(); &#125; else if (name.equals(&quot;transition&quot;)) &#123; drawable = new TransitionDrawable(); &#125; else if (name.equals(&quot;ripple&quot;)) &#123; drawable = new RippleDrawable(); &#125; else if (name.equals(&quot;color&quot;)) &#123; drawable = new ColorDrawable(); &#125; else if (name.equals(&quot;shape&quot;)) &#123; drawable = new GradientDrawable(); &#125; else if (name.equals(&quot;vector&quot;)) &#123; drawable = new VectorDrawable(); &#125; else if (name.equals(&quot;animated-vector&quot;)) &#123; drawable = new AnimatedVectorDrawable(); &#125; else if (name.equals(&quot;scale&quot;)) &#123; drawable = new ScaleDrawable(); &#125; else if (name.equals(&quot;clip&quot;)) &#123; drawable = new ClipDrawable(); &#125; else if (name.equals(&quot;rotate&quot;)) &#123; drawable = new RotateDrawable(); &#125; else if (name.equals(&quot;animated-rotate&quot;)) &#123; drawable = new AnimatedRotateDrawable(); &#125; else if (name.equals(&quot;animation-list&quot;)) &#123; drawable = new AnimationDrawable(); &#125; else if (name.equals(&quot;inset&quot;)) &#123; drawable = new InsetDrawable(); &#125; else if (name.equals(&quot;bitmap&quot;)) &#123; //noinspection deprecation drawable = new BitmapDrawable(r); if (r != null) &#123; ((BitmapDrawable) drawable).setTargetDensity(r.getDisplayMetrics()); &#125; &#125; else if (name.equals(&quot;nine-patch&quot;)) &#123; drawable = new NinePatchDrawable(); if (r != null) &#123; ((NinePatchDrawable) drawable).setTargetDensity(r.getDisplayMetrics()); &#125; &#125; else &#123; throw new XmlPullParserException(parser.getPositionDescription() + &quot;: invalid drawable tag &quot; + name); &#125; drawable.inflate(r, parser, attrs, theme); return drawable; &#125; 上面的对应关系就从这里来的，现在是不是一下子明朗了呢。在函数结尾，Drawable通过条用inflate函数解析AttributeSet中的属性信息，并设置Drawable相应的属性。看一下BitmapDrawable吧，123456789public void inflate(Resources r, XmlPullParser parser, AttributeSet attrs, Theme theme) throws XmlPullParserException, IOException &#123; super.inflate(r, parser, attrs, theme); final TypedArray a = obtainAttributes(r, theme, attrs, R.styleable.BitmapDrawable); updateStateFromTypedArray(a); verifyState(a); a.recycle(); &#125; 继续看updateStateFromTypedArray1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768private void updateStateFromTypedArray(TypedArray a) throws XmlPullParserException &#123; final Resources r = a.getResources(); final BitmapState state = mBitmapState; // Account for any configuration changes. state.mChangingConfigurations |= a.getChangingConfigurations(); // Extract the theme attributes, if any. state.mThemeAttrs = a.extractThemeAttrs(); final int srcResId = a.getResourceId(R.styleable.BitmapDrawable_src, 0); if (srcResId != 0) &#123; final Bitmap bitmap = BitmapFactory.decodeResource(r, srcResId); if (bitmap == null) &#123; throw new XmlPullParserException(a.getPositionDescription() + &quot;: &lt;bitmap&gt; requires a valid src attribute&quot;); &#125; state.mBitmap = bitmap; &#125; state.mTargetDensity = r.getDisplayMetrics().densityDpi; final boolean defMipMap = state.mBitmap != null ? state.mBitmap.hasMipMap() : false; setMipMap(a.getBoolean(R.styleable.BitmapDrawable_mipMap, defMipMap)); state.mAutoMirrored = a.getBoolean( R.styleable.BitmapDrawable_autoMirrored, state.mAutoMirrored); state.mBaseAlpha = a.getFloat(R.styleable.BitmapDrawable_alpha, state.mBaseAlpha); final int tintMode = a.getInt(R.styleable.BitmapDrawable_tintMode, -1); if (tintMode != -1) &#123; state.mTintMode = Drawable.parseTintMode(tintMode, Mode.SRC_IN); &#125; final ColorStateList tint = a.getColorStateList(R.styleable.BitmapDrawable_tint); if (tint != null) &#123; state.mTint = tint; &#125; final Paint paint = mBitmapState.mPaint; paint.setAntiAlias(a.getBoolean( R.styleable.BitmapDrawable_antialias, paint.isAntiAlias())); paint.setFilterBitmap(a.getBoolean( R.styleable.BitmapDrawable_filter, paint.isFilterBitmap())); paint.setDither(a.getBoolean(R.styleable.BitmapDrawable_dither, paint.isDither())); setGravity(a.getInt(R.styleable.BitmapDrawable_gravity, state.mGravity)); final int tileMode = a.getInt(R.styleable.BitmapDrawable_tileMode, TILE_MODE_UNDEFINED); if (tileMode != TILE_MODE_UNDEFINED) &#123; final Shader.TileMode mode = parseTileMode(tileMode); setTileModeXY(mode, mode); &#125; final int tileModeX = a.getInt(R.styleable.BitmapDrawable_tileModeX, TILE_MODE_UNDEFINED); if (tileModeX != TILE_MODE_UNDEFINED) &#123; setTileModeX(parseTileMode(tileModeX)); &#125; final int tileModeY = a.getInt(R.styleable.BitmapDrawable_tileModeY, TILE_MODE_UNDEFINED); if (tileModeY != TILE_MODE_UNDEFINED) &#123; setTileModeY(parseTileMode(tileModeY)); &#125; // Update local properties. initializeWithState(state, r); &#125; updateStateFromTypedArray函数中，BitmapDrawable获取到src属性后，通过BitmapFactory加载图像文件，并读取用户配置的属性，设置BitmapDrawable的其他属性。其他的Drawable的实现方式类似。","categories":[{"name":"android","slug":"android","permalink":"http://blog.ccbu.cc/categories/android/"}],"tags":[]},{"title":"Java垃圾回收","slug":"Java垃圾回收","date":"2017-12-06T14:01:00.000Z","updated":"2017-12-08T07:57:17.568Z","comments":true,"path":"2017/12/06/Java垃圾回收/","link":"","permalink":"http://blog.ccbu.cc/2017/12/06/Java垃圾回收/","excerpt":"","text":"垃圾收集算法 引用计数 堆中的每个对象都有一个引用计数，当对象被引用时引用计数加1，当对象的引用被重新赋值或超出有效区域时引用计数减1，当一个对象被回收后，它所引用的对象的引用计算减1。当一个对象的引用计数变为0时就被回收。 引用计数的优点： 垃圾收集器可以很快地执行，当一个对象的引用数为0时就可以回收这个对象，垃圾收集交织在程序的正常执行过程中，不用长时间中断程序的正常执行。 引用计数的缺点： 每次引用计数的增加和减少会带来额外的开销 无法检测出循环引用 根搜索算法 垃圾检测通过建立一个根对象的集合（局部变量、栈桢中的操作数，在本地方法中引用的对象，常量池等）并检查从这些根对象开始的可触及性来实现。根对象总是可访问的，如果存在根对象到一个对象的引用路径，那么称这个对象是可触及的或活动对象，否则是不可触及的，不可触及的对象就是垃圾对象。 标记清除 分为标记和清除两个阶段，在标记阶段，垃圾收集器跟踪从根对象的引用，在追踪的过程中对遇到的对象打一个标记，最终未被标记的对象就是垃圾对象，在清除阶段，回收垃圾对象占用的内存。可以在对象本身添加跟踪标记，也可以用一个独立的位图来设置标记。 标记清除法是基础的收集算法，其他算法大多时针对这个算法缺点的改进。 有两个缺点： 效率 存在内存碎片 复制算法 将内存划分为大小相等的两个区域，每次只使用其中的一个区域，当这个区域的内存用完了，就将可触及的对象直接复制到新的区域并连续存放以消除内存碎片，当可触及对象复制完后，清除旧内存区域，修改引用的值。 这种算法的缺点很明显，可使用内存变为了原来的一半，太过浪费。 一般情况下，新生代中的对象大多生命周期很短，也就是说当进行垃圾收集时，大部分对象都是垃圾，只有一小部分对象会存活下来，所以只要保留一小部分内存保存存活下来的对象就行了，用不着使用一半的内存。在新生代中一般将内存划分为三个部分：一个较大的Eden空间和两个较小的Survior空间（一样大小），每次使用Eden和一个Survior的内存，进行垃圾收集时将Eden和使用的Survior中的存活的对象复制到另一个Survior空间中，然后清除这两个空间的内存，下次使用Eden和另一个Survior，HotSpot中默认将这三个空间的比例划分为8:1:1，这样被浪费掉的空间就只有总内存的1/10了。 这样的内存空间划分是基于这样一种假设，即每次垃圾收集时大部分对象都是垃圾，只有少部分对象存活。如果遇到例外的情况怎么办，在某次垃圾收集时存活下来的对象超过了预留的那个Survior空间的总大小，这就需要依赖其他的内存进行分配担保了（参考分代收集，前面的描述中也说了这是新生代中的方法） 标记整理 普通的标记清除会在内存中留下内存碎片，复制算法如果不想浪费掉50%内存就需要有内存分配担保，一般是内存分代，但总有一代是没有其他代为它担保的。标记整理算法中标记的过程同标记清理一样，但整理部分不是直接清除掉垃圾对象，而是将活动对象统一移动一内存的一端，然后清除边界外的内存区域，这样就避免了内存碎片。也不会浪费内存，不需要其他内存进行担保 分代收集 大多数程序中创建的大部分对象生命周期都很短，而且会有一小部分生命周期长的对象，为了克服复制收集器中每次垃圾收集都要拷贝所有的活动对象的缺点，将内存划分为不同的区域，更多地收集短生命周期所在的内存区域，当对象经历一定次数的垃圾收集存活时，提升它的存在的区域。一般是划分为新生代和老年代。新生代又划分为Eden区，From Survior区和To Survior区。 自适应收集器 监听堆中的情形，并且对应地调用合适的垃圾收集技术。 垃圾收集器 Serial 一个单线程的收集器，在进行垃圾收集时会暂停其他线程的工作，不适合用到Server端的虚拟机，但Client模式的模拟机还是可以用的，因为Client模式下的应用分配到的系统内存一般不大，垃圾收集可以很快完成。优点就是简单高效，没有线程交互开销，可以获得最高的单线程收集效率。 ParNew Seria的多线程版本，可以多个线程收集垃圾，但如果CPU只有一核且没有超线程，效果就不一定比Serial好了，如果是多核或有超线程，可以保证效果好于Serial，除Seria之外，这是唯一能与CMS收集器配合的垃圾收集器 Parallel Scavenge 使用复制算法的新生代多线程垃圾收集器，Parallel Scavenge收集器的关注点和其他收集器不同，其他收集器的关注点是尽可能缩短垃圾收集时用户线程等待的时间，而Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（Throughput），即CPU用于运行用户代码的时间与CPU总消耗时间的比值。以缩短用户线程等待时间的收集器适合用于需要与用户交互的程序，而以吞吐量为目标的收集器适合用于不需要和用户太多的交互，以后台运算为目标的任务。 Parallel Scavenge可以通过参数设置每次垃圾收集需要停顿的时间和吞吐量目标，但停顿时间并不是越小越好，这是以牺牲吞吐量和新生代空间为代价的，因为要使垃圾收集停顿时间缩小，只能进行少量多次收集，或减小需要收集的空间大小。 还有一个-XX:UseAdaptiveSizePolicy参数，指定这个参数后，就不需要手工指定新生代的大小、Eden区和Survior区的比例大小和晋升老年代对象年龄等细节参数了，虚拟机会根据收集到的信息动态调整这些参数，这称为自适应策略。 Serial Old Serial的老年代版本，单线程收集器，使用”标记-整理”算法，主要被Client模式下的虚拟机使用，当被使用在Server模式时主要有两个用途： 与Parallel Scavenge配合使用 作为CMS收集失败时的备选方案。 Parallel Old Parallel Scavenge的老年代版本，使用”标记-整理”算法，JDK1.6后提供的，在此之前，如果新生代选择了Parallel Scavenge，老年代只能选择Serial Old，由于Serial Old是单线程的垃圾收集器，可能会影响收集性能。Parallel Old出现后，就可以分别在新生代和老年代选择Parallel Scavenge和Parallel Old组合了。 CMS(Concurrent Mark Sweep) 以获取最短回收停顿时间为目标的收集器，使用“标记-清除”算法，整个回收过程分为以下4步： 初始标记（CMS Initial Mark） 并发标记（CMS Current Mark） 重新标记（CMS Remark） 并发清楚（CMS Concurrent Sweep） 初始标记与重新标记阶段仍会暂停用户线程的运行。 初始标记只是记录下GC Root能直接关联到的对象，速度很快。 并发标记就是GC Roots Tracing了，速度较慢，但可以和用户线程同时运行。 重新标记是修正并发标记时由于用户线程运行导致的标记记录变动，这个阶段会使用户线程停顿，停顿时间比初始标记略长，但仍小于重新标记。 并发清除就是清除垃圾对象了，耗时较长，但可与用户线程同时工作。 CMS的缺点 对CPU资源敏感，并发阶段和用户线程同时运行，影响服务器的响应速度，尤其是CPU核心数少时 无法处理浮动垃圾，由于并发阶段用户线程同时在运行，可能会在垃圾收集过程中产生新的垃圾，CMS无法处理这部分浮动垃圾，由于在进行垃圾收集时用户线程同时在运行，需要额外的内存空间，所以不能等到内存满时再进行GC，需要预留一部分空间，如果预留的这部分空间不够GC时用户线程创建新对象使用，就会使用预备方法，使用Serial Old进行一次Full GC。 CMS基于“标记-清除”算法，进行垃圾回收后会存在内存碎片，当申请大的连续内存时可能内存不足，此时需要进行一次Full GC，可以通过参数指定进行Full GC后或进行多少次Full GC后进行一次内存压缩来整理内存碎片。 G1(Garbage First) 基于”标记-整理”算法，避免了内存碎片的问题，并可精确地控制垃圾回收时的停顿。 G1收集器可以实现基本不牺牲吞吐量的前提下完成低停顿的内存回收，不同于之前的垃圾回收器，G1收集器的回收区域不是整个新生代或老年代，而是将整个Java堆划分为多个固定大小的区域，并跟踪这些区域里的垃圾堆积程度，在后台维护一个优先列表，优先回收垃圾最多的区域。区域的划分使每次回收时间变短，而优先级的划分使得每次回收的区域可以回收最多的垃圾，这就使用G1收集器可以在有限的时间内获取最高的收集效率。 内存分配与回收策略 对像优先在新生代Eden区分配，当Eden区没有足够的内存时会发生一次Minor GC（新生代GC，Major GC或Full GC是老年代GC） 大对象可以直接在老年代分配内存，可以通过参数指定一个大小，大于这个大小的对象直接在老年代中分配内存。 进行Minor GC时，Eden区和一个Survior区中存活的对象会被复制到另一个Survior区，一个对象每在一次Minor GC中存活下来一次后这个对象的年龄就加1，当这个对象的年龄大于一定值（默认15）就会进入老年代。 如果Survior中相同年龄的对象占用的空间大于Survior空间的一半，那么年龄大于或等于这个年龄的对象会直接进入老年代，而不用等到达到特定年龄 当进行Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果小于，判断是否开启了HandlerPromotionFailure允许担保失败，如果开启了就只进行Minor GC，否则进行Full GC。由于使用的之前Minor GC时的平均大小，如果某一次突然大小变大，导致老年代剩余空间不够，即担保失败，会再进行一次Full GC。 finalize GC时会对活动对象进行标记，没有被标记的对象就是垃圾对象，但垃圾对象不会直接被清除，垃圾收集器还会判断是否需要执行对象的finalize方法，如果对象没有覆写finalize方法或它的finalize已经被执行过一次，那么是没有必要执行的，否则就认为是有必要执行的，当被判断为有必要执行时，这个对象会被放入一个F-Queue队列中，由一个后台的低优先级的Finalizer线程执行队列中的对象的finalize方法，对象可以在这个方法中中复活自己，即重新被其他对象引用，但这个函数只会被垃圾收集器运行一下，第二次回收这个对象时这个函数不会再被调用。稍后GC会对F-Queue队列中的对象执行第二次标记。 FROM : www.cnblogs.com/angeldevil","categories":[{"name":"android","slug":"android","permalink":"http://blog.ccbu.cc/categories/android/"}],"tags":[]},{"title":"Android.os.SystemClock 介绍","slug":"SystemClock","date":"2017-12-06T14:01:00.000Z","updated":"2017-12-08T07:57:17.568Z","comments":true,"path":"2017/12/06/SystemClock/","link":"","permalink":"http://blog.ccbu.cc/2017/12/06/SystemClock/","excerpt":"","text":"Android.os.SystemClock 介绍Class Overview Core timekeeping facilities. Three different clocks are available, and they should not be confused: System.currentTimeMillis() is the standard “wall” clock (time and date) expressing milliseconds since the epoch. The wall clock can be set by the user or the phone network (see setCurrentTimeMillis(long)), so the time may jump backwards or forwards unpredictably. This clock should only be used when correspondence with real-world dates and times is important, such as in a calendar or alarm clock application. Interval or elapsed time measurements should use a different clock. If you are using System.currentTimeMillis(), consider listening to the ACTION_TIME_TICK, ACTION_TIME_CHANGED andACTION_TIMEZONE_CHANGED Intent broadcasts to find out when the time changes.该时间是基于世界时间的，它返回的是从January 1, 1970 00:00:00 UTC到现在时间已经逝去了多多少millisecond，当我设置Android手机的系统时间时，会应该影响该值。 uptimeMillis() is counted in milliseconds since the system was booted. This clock stops when the system enters deep sleep (CPU off, display dark, device waiting for external input), but is not affected by clock scaling, idle, or other power saving mechanisms. This is the basis for most interval timing such asThread.sleep(millls), Object.wait(millis), and System.nanoTime(). This clock is guaranteed to be monotonic, and is the recommended basis for the general purpose interval timing of user interface events, performance measurements, and anything else that does not need to measure elapsed time during device sleep. Most methods that accept a timestamp value expect the uptimeMillis() clock.它表示的是手机从启动到现在的运行时间，且不包括系统sleep(CPU关闭)的时间，很多系统的内部时间都是基于此，比如Thread.sleep(millls), Object.wait(millis), and System.nanoTime() elapsedRealtime() is counted in milliseconds since the system was booted, including deep sleep. This clock should be used when measuring time intervals that may span periods of system sleep.它表示的是手机从启动到现在的运行时间，且包括系统sleep(CPU关闭)的时间 There are several mechanisms for controlling the timing of events(有几种机制控制事件发生的时间): Standard functions like Thread.sleep(millis) and Object.wait(millis) are always available. These functions use the uptimeMillis() clock; if the device enters sleep, the remainder of the time will be postponed until the device wakes up. These synchronous functions may be interrupted withThread.interrupt(), and you must handle InterruptedException.标准的方法像Thread.sleep(millis) 和 Object.wait(millis)总是可用的，这些方法使用的是uptimeMillis()时钟，如果设备进入深度休眠，剩余的时间将被推迟直到系统唤醒。这些同步方法可能被Thread.interrupt()中断，并且你必须处理InterruptedException异常。 SystemClock.sleep(millis) is a utility function very similar to Thread.sleep(millis), but it ignores InterruptedException. Use this function for delays if you do not use Thread.interrupt(), as it will preserve the interrupted state of the thread.SystemClock.sleep(millis)是一个类似于Thread.sleep(millis)的实用方法，但是它忽略InterruptedException异常。使用该函数产生的延迟如果你不使用Thread.interrupt()，因为它会保存线程的中断状态。 The Handler class can schedule asynchronous callbacks at an absolute or relative time. Handler objects also use the uptimeMillis() clock, and require anevent loop (normally present in any GUI application).Handler可以在一个相对或者绝对的时间设置异步回调，Handler类对象也使用uptimeMillis()时钟，而且需要一个loop(经常出现在GUI程序中)。 The AlarmManager can trigger one-time or recurring events which occur even when the device is in deep sleep or your application is not running. Events may be scheduled with your choice of currentTimeMillis() (RTC) or elapsedRealtime() (ELAPSED_REALTIME), and cause an Intent broadcast when they occur.AlarmManager可以触发一次或重复事件，即使设备深度休眠或者应用程序没有运行。事件可以选择用 currentTimeMillis或者elapsedRealtime()(ELAPSED_REALTIME)来设置时间，当事件发生会触发一个广播。 常用函数| return |methods | || —- | —- | —- ||static long|currentThreadTimeMillis()|Returns milliseconds running in the current thread.||static long|elapsedRealtime()|Returns milliseconds since boot, including time spent in sleep.||static long|elapsedRealtimeNanos()|Returns nanoseconds since boot, including time spent in sleep.||static boolean|setCurrentTimeMillis(long millis)|Sets the current wall time, in milliseconds.||static void|sleep(long ms)|Waits a given number of milliseconds (of uptimeMillis) before returning.||static long|uptimeMillis()|Returns milliseconds since boot, not counting time spent in deep sleep.| 注释： 1、public static long currentThreadTimeMillis () 返在当前线程运行的毫秒数。 2、public static long elapsedRealtime () 返回系统启动到现在的毫秒数，包含休眠时间。 3、public static long elapsedRealtimeNanos () 返回系统启动到现在的纳秒数，包含休眠时间。 4、public static boolean setCurrentTimeMillis (long millis) 设置当前wall time，要求调用进程有许可权限。返回是否成功。 5、public static void sleep (long ms) 等待给定的时间。和Thread.sleep(millis)类似，但是它不会抛出InterruptedException异常。事件被推迟到下一个中断操作。该方法直到指定的时间过去才返回。 6、public static long uptimeMillis () 返回系统启动到现在的毫秒数，不包含休眠时间。就是说统计系统启动到现在的非休眠期时间。","categories":[{"name":"android","slug":"android","permalink":"http://blog.ccbu.cc/categories/android/"}],"tags":[]},{"title":"Activity启动模式","slug":"Activity启动模式","date":"2017-12-04T14:17:00.000Z","updated":"2017-12-08T07:57:17.568Z","comments":true,"path":"2017/12/04/Activity启动模式/","link":"","permalink":"http://blog.ccbu.cc/2017/12/04/Activity启动模式/","excerpt":"","text":"Activity启动模式Android系统是通过Activity栈的方式来管理Activity的，而按照栈的特性，系统每创建一个新的Activity都会把其实例放入栈中，而按back键退出时，则从栈顶移除该Activity。而这种管理方式太过简单粗暴，当重复启动一个Activity时，会创建很多个实例，因此在很多情况下无法满足需求，因此，Android系统使用了Activity启动模式并配合Activity栈来完成对系统中各个Activity的管理。 Activity启动模式有以下四种： standard singleTop singleTask singleInstance 在开发过程中，我们根据应用场景及需要的不同选择合适的启动模式。设置Activity的启动模式，只需要在AndroidManifest.xml里对应的标签设置android:launchMode属性。 12&lt;activity android:launchMode=&quot;standard&quot; /&gt; standard 模式默认模式，可以不用写配置。在这种模式下，每启动一个Activity都会创建一个新的实例，也不会理会该实例是否已经存在。一般情况下，谁启动了改模式的Activity，该Activity就会放入启动它的Activity所在的任务栈中。同时被启动的Activity的onCreate()，onStart()，onResume()方法都会被调用。也就是说这种模式下，同一个任务栈中允许有多个该Activity的实例，该Activity的多实例也可以同时存在于不同的任务栈中。 singleTop 模式可以有多个实例，但是不允许多个相同Activity叠加。即，如果已经有一个Activity在当前任务栈的栈顶了，再去启动一个相同的Activity，那么则不会创建新的实例，而是直接调用其onNewIntent方法。该模式与standard模式不同之处在于如果当前任务栈顶已经有了该Activity的实例，那么就不会再去创建新的实例，其他特性则与standard模式完全相同。 singleTask 模式只有一个实例。在同一个应用程序中启动的时候，若Activity不存在，则会在当前任务栈中创建一个新的实例，若存在，则会把任务栈中其他在其之上的其它Activity全部destory掉并调用其onNewIntent方法。如果是在别的应用程序中启动它，则会新建一个任务栈，并在该任务栈中启动这个Activity，singleTask允许别的Activity与其在一个任务栈中共存，也就是说，如果我在这个singleTask的实例中再打开新的Activity，这个新的Activity还是会在singleTask的实例的任务栈中。 singleInstance 模式只有一个实例，并且这个实例独立运行在一个task中，这个task只有这个实例，不允许有别的Activity存在。以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。 note: 在详细分析了四种启动模式后，我们需要知道的是，加入启动模式后，启动一个Activity可能有两种方式，一种是创建一个新的Activity实例并启动，此时Activity的onCreate()，onStart()，onResume()方法都会被调用;而当Activity是复用已经存在的实例时，则会将其置于栈顶的同时去调用其onNewIntent方法。此时Activity的onCreate()，onStart()方法是不会被调用的，但onResume()会被调用。 使用Intent的flag设置启动模式当你启动一个Activity时，你也可以动态的设置intent的flag，然后通过startActivity()方法启动activity，从而修改其启动的activity与它的task的关联模式。具体可以使用的flag有： FLAG_ACTIVITY_NEW_TASK:对应之前的“singleTask”，在新的task中启动activity，如果一个你需要的activity的task已经存在，则将它推向前台，恢复其上一个状态，它通过onNewIntent()收到这个新的intent。 FLAG_ACTIVITY_SINGLE_TOP:对应之前的“singleTop”,如果被启动的activity是当前顶部的activity，则已经存在的实例会收到onIntent(),而不会重新去创建这个实例。 FLAG_ACTIVITY_CLEAR_TOP:这个行为在launchMode属性中没对应的属性值，若被启动的activity已经在当前task中运行，则不会创建它的新实例，而是的销毁在它之上的其他所有的activities，然后通过 onNewIntent()传递一个新的intent给这个恢复了的activity，它一般会与FLAG_ACTIVITY_NEW_TASK一起使用。值得注意的是，如果activity的启动模式是”standard”，它自己也将被移除，然后一个新的实例将被启动。这是因为当启动模式是”standard”时，为了接收新的intent必须创建新的实例。 任务共用性的处理(Handling affinities)一般来说，singleTask就是开启一个新的Task，但是在实际使用过程中，我们有时会发现，有时候并不是这样的，这是因为我们定义了affinities,也就是任务公用性。 affinity定义了一个Activity将被分配到哪一个Task中。默认情况下，同一个app中得所有activity有一个同样的affinity，因此，默认情况下同一个应用程序中得所有activity都在同一个task中。一个Task的affinity由这个Task的根Actiivty决定。然而，我们可以修改Activity默认的affinity，这样，不同应用程序的Activity可以共用同样的affinity，或者同一个程序的不同Activity分配不同的affinity。一个应用程序默认的affinity就是应用程序的包名，所以，如果我们想定义一个不同的affinity，必须和默认的affinity不同。我们可以通过中得android:taskAffinity修改整个程序的affinity，也可以通过的android:taskAffinity对单个Activity的affinity修改。 而affinity的使用通常有以下两种情况， 当android:launchMode是singleTask或者Intent中包含FLAG_ACTIVITY_NEW_TASK: 默认情况下，我们调用startActivity()，会实例化一个Activity，放入到与调用者相同的task。但是如果这个Activity的的启动模式是singleTask，或者启动它的Intent包含了 FLAG_ACTIVITY_NEW_TASK时，系统会进行如下的步骤： 判断这个Activity有没有实例已经存在了，有的话，直接传递Intent到它的onNewIntent()方法中。 如果不存在，系统查找是否有与这个Activity相同affinity的Task已经存在，如果存在，那么就将这个Activity启动到这个Task中。 如果不存在这样的Task，那么系统就会创建一个新的Task，并且将这个Activity启动这个Task中，作为根Activity。 因此，从现在看来，只是单纯的用singleTask指定Activity，是不能开辟一个新的Task的，因为我们并没有给他指定affinity。而官方文档对于singleTask的描述，都是基于我们使用了不同的affinity的前提下，只不过是省略了这个描述。所以，我们要明白，singleTask的正确用法，应该是结合affinity使用的。 当一个Activity设置allowTaskReparenting属性为true: 这个属性定义了一个Activity，表示是否可以从一个启动它的task，切换到与它相同affinity的task中里去（当这个task切换到前台的时候）。true表示可以移动，false表示它必须呆在启动他得task里。 通常情况下，当一个Activity启动了，那么它就会存在于启动它的task中，并且在整个生命周期中都留在这个task中。但是，我们可以通过这个属性，做出如下改变，当这个Activity当前的Task处于后台，这个时候如果有一个该Activity具有相同affinity的Task被启动到前台，那么这个Activity就可以从它之前的Task，移动到这个新的Task显示。 通常，它的作用是将app中得Activity与app的main task结合起来，举个例子，如下： 有一个e-mail程序，他需要调用浏览器程序的某个Activity（假设为Activity A）来显示一些数据，这个Activity A的该属性设置为true。现在，e-mail程序调用了这个Activity A，在用户看来，好像这个Activity A就是e-mial程序的一部分，因为这个Activity A和这个e-mail程序在同一个task中。现在将e-mail退出到后台，启动浏览器程序，因为Activity A和浏览器程序有相同的affinity，所以Activity A从e-mail程序的Task移动到浏览器程序的Task，并显示在前台。当我们下次再启动e-mail程序时，Activity A就不会存在，因为他已经移动到浏览器程序的Task里去了。 清理Back Stack如果用户离开一个task很久，系统就会清理这个task中除了根activity之外的所有activities。当用户返回到这个task，只有根activity会被恢复。但是我们可以设置一些activity的属性，用来改变这一行为： alwaysRetainTaskState 如果这个属性在task的根activity中被设置为true，那么上面描述的默认行为不会发生，即便过了很长时间，task仍将会保持所有的activities。 clearTaskOnLaunch 如果这个属性在task的根activity中被设置为true，每次用户离开这个task，整个task都会被清到只剩根activity，这样用户只会永远返回到它最初的状态，即便离开的时间很短。 finishOnTaskLaunch 这个属性和上一个很像，不同的是，它只作用于单个activity，而不是整个task。它可以引起任何activity离开，包括根activity。当它被设置为true时，这个activity只在当前会话中属于这个task，如果用户离开后再返回，它也不会再出现。 开启一个Task我们可以通过一个Activity指定一个intent过滤器，如下面： 1234567&lt;activity ...&gt; &lt;intent-filter ... &gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.inp tent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; ...&lt;/activity&gt; 这时这个activity就作为根activity存在于一个task中，这个activity也是进入这个task的入口点，同时，它的图标和标签也会被显示在应用启动界面上，这时用户就可以启动这个activity并且再次回到这个任务。因此，从这里我们可以看到，要使用“singleTask”与“singleInstance”，就必须这个activity应当也有ACTION_MAIN与CATEGORY_LAUNCHER过滤器。因为假如没有设置这两个过滤器的话，当一个intent启动一个”singleTask”的activity,在新的Task中进行初使化，运行一段时间后，用户突然按上了home键回到桌面，此时这个Task就被移到后台并且不可见，因为这个activity没有设置过滤器，所以不是应用启动的activity，那么用户也就无法返回到这个Task中了。","categories":[{"name":"android","slug":"android","permalink":"http://blog.ccbu.cc/categories/android/"}],"tags":[]},{"title":"Android知识体系","slug":"Android知识体系","date":"2017-12-04T14:17:00.000Z","updated":"2017-12-08T07:57:17.568Z","comments":true,"path":"2017/12/04/Android知识体系/","link":"","permalink":"http://blog.ccbu.cc/2017/12/04/Android知识体系/","excerpt":"","text":"Android知识体系基础组件 Application PackageManager Activity Activity生命周期 Activity启动模式 Stack与Task ActivityManager Service Service创建方式（2种） IntentService ServiceManager ContentProvider 联系人Demo BroadcastReceiver 注册方式、区别 LocalBroadcast Fragment 生命周期 Fragment的管理和事务处理 创建方式 与Activity通信 Intent 基础概念 过滤匹配方式 Loader CursorLoader AsyncTAskLoader Window WindowManager 与Activity、View关系 View视图视图控件 基础布局 LinearLayout RelativeLayout FrameLayout TableLayout（继承自LinearLayout） AbsoluteLayout（已被标注过时） 常用控件 TextView Button ImageView ListView … 视图的工作原理 layout/measure/draw VSYNC/DisplayList… hwui 事件体系、传递机制 拦截/分发/处理 滑动冲突解决 自定义视图 继承、组合 Paint、Canvas使用 资源 Resource assets raw res Theme应用与管理 layout anim values … R文件相关 Drawable mipmap","categories":[{"name":"android","slug":"android","permalink":"http://blog.ccbu.cc/categories/android/"}],"tags":[]},{"title":"C++知识体系","slug":"C-知识体系","date":"2017-12-04T14:01:00.000Z","updated":"2017-12-08T07:57:17.568Z","comments":true,"path":"2017/12/04/C-知识体系/","link":"","permalink":"http://blog.ccbu.cc/2017/12/04/C-知识体系/","excerpt":"","text":"C++知识体系结构C++基础数据类型封装重载继承和多态内存管理模板异常处理其他指针与引用命名空间c++作用域命名空间浅拷贝与深拷贝及写时拷贝####","categories":[{"name":"cpp","slug":"cpp","permalink":"http://blog.ccbu.cc/categories/cpp/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-12-03T04:07:00.000Z","updated":"2017-12-08T07:57:17.568Z","comments":true,"path":"2017/12/03/hello-world/","link":"","permalink":"http://blog.ccbu.cc/2017/12/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}